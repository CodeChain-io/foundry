pub trait MyHandle : Service { fn fn_1 ( & self , a : i32 , b : String ) -> String ; fn fn_2 ( & self , a : i32 , b : Vec < u8 > ) -> Box < dyn MyHandle > ; } static ID_TRAIT_MyHandle : TraitIdAtomic = TraitIdAtomic :: new ( 0 ) ; # [ distributed_slice ( TID_REG ) ] static ID_TRAIT_ENTRY_MyHandle : ( & 'static str , fn ( id : TraitId ) ) = ( "MyHandle" , id_trait_setter_MyHandle ) ; fn id_trait_setter_MyHandle ( id : TraitId ) { ID_TRAIT_MyHandle . store ( id , ID_ORDERING ) ; } static ID_METHOD_MyHandle_fn_1 : MethodIdAtomic = MethodIdAtomic :: new ( 7 ) ; # [ distributed_slice ( MID_REG ) ] static ID_METHOD_ENTRY_MyHandle_fn_1 : ( & 'static str , & 'static str , fn ( id : MethodId ) ) = ( "MyHandle" , "fn_1" , id_method_setter_MyHandle_fn_1 ) ; fn id_method_setter_MyHandle_fn_1 ( id : MethodId ) { ID_METHOD_MyHandle_fn_1 . store ( id , ID_ORDERING ) ; } static ID_METHOD_MyHandle_fn_2 : MethodIdAtomic = MethodIdAtomic :: new ( 8 ) ; # [ distributed_slice ( MID_REG ) ] static ID_METHOD_ENTRY_MyHandle_fn_2 : ( & 'static str , & 'static str , fn ( id : MethodId ) ) = ( "MyHandle" , "fn_2" , id_method_setter_MyHandle_fn_2 ) ; fn id_method_setter_MyHandle_fn_2 ( id : MethodId ) { ID_METHOD_MyHandle_fn_2 . store ( id , ID_ORDERING ) ; } impl association :: Export for TraitHolder < dyn MyHandle > { type T = dyn MyHandle ; fn export ( port_id : PortId , handle : Box < dyn MyHandle > ) -> HandleInstance { register ( port_id , ID_TRAIT_MyHandle . load ( ID_ORDERING ) , handle . box_to :: < dyn Service > ( ) . expect ( "Trait casting failed" ) ) } } impl association :: Dispatch for TraitHolder < dyn MyHandle > { type T = dyn MyHandle ; fn dispatch ( object : & dyn MyHandle , method : MethodId , arguments : & [ u8 ] , return_buffer : std :: io :: Cursor < & mut Vec < u8 >> ) { if method == ID_METHOD_MyHandle_fn_1 . load ( ID_ORDERING ) { let ( a1 , a2 , ) = serde_cbor :: from_reader ( & arguments [ std :: mem :: size_of :: < PacketHeader > ( ) .. ] ) . unwrap ( ) ; let result = object . fn_1 ( a1 , a2 ) ; serde_cbor :: to_writer ( return_buffer , & result ) . unwrap ( ) ; return ; } if method == ID_METHOD_MyHandle_fn_2 . load ( ID_ORDERING ) { let ( a1 , a2 , ) = serde_cbor :: from_reader ( & arguments [ std :: mem :: size_of :: < PacketHeader > ( ) .. ] ) . unwrap ( ) ; let result = object . fn_2 ( a1 , a2 ) ; let result = register ( object . get_handle ( ) . for_dispatcher_get_port_id ( ) , ID_TRAIT_MyHandle . load ( ID_ORDERING ) , result . box_to :: < dyn Service > ( ) . expect ( "Trait casting failed" ) ) ; serde_cbor :: to_writer ( return_buffer , & result ) . unwrap ( ) ; return ; } panic ! ( "Invalid handle call. Fatal Error." ) } } pub struct MyHandleImported { handle : HandleInstance } impl MyHandle for MyHandleImported { fn fn_1 ( & self , a : i32 , b : String ) -> String { call ( & self . handle , ID_METHOD_MyHandle_fn_1 . load ( ID_ORDERING ) , & ( a , b ) ) } fn fn_2 ( & self , a : i32 , b : Vec < u8 > ) -> Box < dyn MyHandle > { let handle = MyHandleImported { handle : call ( & self . handle , ID_METHOD_MyHandle_fn_2 . load ( ID_ORDERING ) , & ( a , b ) ) } ; Box :: new ( handle ) } } impl Service for MyHandleImported { fn get_handle ( & self ) -> & HandleInstance { & self . handle } fn get_handle_mut ( & mut self ) -> & mut HandleInstance { & mut self . handle } } impl Drop for MyHandleImported { fn drop ( & mut self ) { delete ( & self . handle ) } } impl association :: Import for TraitHolder < dyn MyHandle > { type T = dyn MyHandle ; fn import ( handle : HandleInstance ) -> Box < dyn MyHandle > { Box :: new ( MyHandleImported { handle , } ) } } impl ServiceDispatcher for MyHandleImported { fn dispatch ( & self , _method : MethodId , _arguments : & [ u8 ] , _return_buffer : std :: io :: Cursor < & mut Vec < u8 >> ) { panic ! ( ) } }